<!DOCTYPE html>
<html lang="{{ site.lang | default: "en-US" }}">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    {% seo %}
    <link rel="stylesheet" href="{{ "/assets/css/style.css?v=" | append: site.github.build_revision | relative_url }}">

    <style>
      body {
        cursor: none;
      }

      .cursor {
        position: fixed;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(20,20,20,0.9);
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 9999;
      }

      #antigravityCanvas {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 0;
      }

      .wrapper {
        position: relative;
        z-index: 1;
      }
    </style>

    {% include head-custom.html %}
  </head>

  <body>
    <div class="cursor"></div>
    <canvas id="antigravityCanvas"></canvas>

    <div class="wrapper">
      <header>
        <h1><a href="{{ "/" | absolute_url }}">{{ site.title | default: site.github.repository_name }}</a></h1>
        <p>{{ site.description | default: site.github.project_tagline }}</p>
      </header>

      <section>
        {{ content }}
      </section>

      <footer>
        <p><small>Hosted on GitHub Pages</small></p>
      </footer>
    </div>

    <script src="{{ "/assets/js/scale.fix.js" | relative_url }}"></script>

    <!-- Cursor-Centric Antigravity Fluid Field -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {

        /* ---------- Cursor ---------- */
        const cursor = document.querySelector(".cursor");

        /* ---------- Canvas ---------- */
        const canvas = document.getElementById("antigravityCanvas");
        const ctx = canvas.getContext("2d");

        function resize() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener("resize", resize);

        /* ---------- Mouse ---------- */
        const mouse = {
          x: canvas.width / 2,
          y: canvas.height / 2,
          vx: 0,
          vy: 0
        };

        let last = { x: mouse.x, y: mouse.y };

        document.addEventListener("mousemove", e => {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
          mouse.vx = mouse.x - last.x;
          mouse.vy = mouse.y - last.y;
          last.x = mouse.x;
          last.y = mouse.y;

          cursor.style.left = mouse.x + "px";
          cursor.style.top = mouse.y + "px";
        });

        /* ---------- Color Palette ---------- */
        const palette = [
          [88,101,242],
          [52,211,153],
          [96,165,250],
          [250,204,21],
          [244,114,182],
          [167,139,250]
        ];

        const lerp = (a,b,t) => a + (b-a)*t;

        function fieldColor(angle, wave) {
          const idx = Math.floor(angle / (Math.PI * 2) * palette.length);
          const next = (idx + 1) % palette.length;
          const t = (Math.sin(wave) + 1) / 2;

          return `rgba(
            ${lerp(palette[idx][0], palette[next][0], t)},
            ${lerp(palette[idx][1], palette[next][1], t)},
            ${lerp(palette[idx][2], palette[next][2], t)},
            0.75
          )`;
        }

        /* ---------- Particles ---------- */
        const particles = [];
        const COUNT = 420;
        const SPHERE_RADIUS = 1200;

        class Particle {
          constructor(i) {
            this.angle = Math.random() * Math.PI * 2;
            this.radius = Math.random() * SPHERE_RADIUS;
            this.waveOffset = Math.random() * Math.PI * 2;
            this.size = Math.random() * 2 + 1;
            this.x = mouse.x;
            this.y = mouse.y;
            this.vx = 0;
            this.vy = 0;
          }

          update(time) {
            // Stress wave
            const wave = Math.sin(time * 0.003 + this.waveOffset);

            // Target radial position relative to cursor
            const targetX =
              mouse.x + Math.cos(this.angle) * (this.radius + wave * 12);
            const targetY =
              mouse.y + Math.sin(this.angle) * (this.radius + wave * 12);

            // Spring force to target
            this.vx += (targetX - this.x) * 0.02;
            this.vy += (targetY - this.y) * 0.02;

            // Cursor motion drag
            this.vx += mouse.vx * 0.04;
            this.vy += mouse.vy * 0.04;

            // Damping
            this.vx *= 0.85;
            this.vy *= 0.85;

            this.x += this.vx;
            this.y += this.vy;
          }

          draw(time) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fillStyle = fieldColor(this.angle, time * 0.004 + this.waveOffset);
            ctx.fill();
          }
        }

        for (let i = 0; i < COUNT; i++) {
          particles.push(new Particle(i));
        }

        /* ---------- Animation ---------- */
        function animate(time) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          particles.forEach(p => {
            p.update(time);
            p.draw(time);
          });
          requestAnimationFrame(animate);
        }

        animate(0);
      });
    </script>
  </body>
</html>
